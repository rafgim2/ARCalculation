<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>AR MULTIMUSIC - Versión Completa</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    /* Estilos generales para ambas versiones */
    body { margin: 0; overflow: hidden; font-family: sans-serif; background: #222; color: #fff; }

    /* Overlay inicial (para configuración y fallback 2D) */
    #overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: #aaf951;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
      box-sizing: border-box;
    }
    #overlay img { max-width: 80%; margin-bottom: 20px; border-radius: 10px; }
    #overlay input, #overlay select, #overlay button {
      font-size: 18px;
      padding: 10px;
      margin: 10px 0;
      border: none;
      border-radius: 5px;
    }
    #overlay button { background: green; color: #fff; cursor: pointer; }

    /* Contenedor 2D del juego */
    #gameContainer {
      display: none;
      width: 100%;
      height: 100vh;
      position: relative;
      text-align: center;
      padding-top: 20px;
      box-sizing: border-box;
    }
    #questionContainer { font-size: 2em; margin-bottom: 20px; }
    #answersContainer { margin-bottom: 20px; }
    #answersContainer button {
      font-size: 1.5em;
      margin: 10px;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      background: #007BFF;
      color: #fff;
      cursor: pointer;
    }
    #infoContainer {
      font-size: 1.2em;
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
    }
    /* Leaderboard 2D */
    #leaderboardContainer {
      margin-top: 20px;
      max-width: 90%;
      margin-left: auto;
      margin-right: auto;
      background: #333;
      padding: 10px;
      border-radius: 8px;
      font-size: 1em;
      text-align: left;
    }
    #leaderboardContainer table {
      width: 100%;
      border-collapse: collapse;
    }
    #leaderboardContainer th, #leaderboardContainer td {
      border: 1px solid #555;
      padding: 5px;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Overlay inicial para configuración (visible en ambas ramas antes de iniciar el juego) -->
  <div id="overlay">
    <img src="ARCalc.jpeg" alt="ARCalc">
    <input type="text" id="playerName" placeholder="Ingresa tu nombre">
    <div>
      <label for="numAnswers">Número de respuestas:</label>
      <select id="numAnswers">
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
      </select>
    </div>
    <button id="startButton">Iniciar Juego</button>
  </div>

  <!-- Contenedor 2D del juego (solo se usa en modo 2D) -->
  <div id="gameContainer">
    <div id="questionContainer">La pregunta aparecerá aquí</div>
    <div id="answersContainer"></div>
    <div id="infoContainer">
      <div id="countdownTimer">00:60</div>
      <div id="scoreDisplay">Aciertos: 0 | Fallos: 0</div>
    </div>
    <div id="leaderboardContainer">
      <h3>Leaderboard</h3>
      <div id="leaderboardPreview">Cargando...</div>
    </div>
  </div>

  <script type="module">
    /**************** Firebase y Firestore ****************/
    // Configuración de Firebase (utiliza la misma en AR y 2D)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
    import { 
      getFirestore, collection, addDoc, orderBy, getDocs, serverTimestamp,
      query, where, limit, updateDoc, doc
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    const firebaseConfig = {
      apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
      authDomain: "arm1-acbba.firebaseapp.com",
      projectId: "arm1-acbba",
      storageBucket: "arm1-acbba.firebasestorage.app",
      messagingSenderId: "408825932019",
      appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
      measurementId: "G-S78TM6PVRL"
    };
    const appFirebase = initializeApp(firebaseConfig);
    const analytics = getAnalytics(appFirebase);
    const db = getFirestore(appFirebase);

    // Función para actualizar el leaderboard (se muestra en la versión 2D)
    async function updateLeaderboardPreview2D(numAnswers) {
      const collectionName = `Calcleaderboard_${numAnswers}`;
      try {
        const q = query(collection(db, collectionName), orderBy("score", "desc"), limit(10));
        const querySnapshot = await getDocs(q);
        let html = "<table><tr><th>Pos</th><th>Nombre</th><th>Puntos</th></tr>";
        let pos = 1;
        querySnapshot.forEach(docSnap => {
          const data = docSnap.data();
          html += `<tr><td>${pos}</td><td>${data.name}</td><td>${data.score}</td></tr>`;
          pos++;
        });
        html += "</table>";
        document.getElementById("leaderboardPreview").innerHTML = html;
      } catch(e) {
        console.error("Error actualizando leaderboard:", e);
        document.getElementById("leaderboardPreview").innerHTML = "Error cargando leaderboard.";
      }
    }

    /**************** Funciones Comunes de Juego ****************/
    // Genera una pregunta aritmética
    function generateQuestionExpr() {
      const ops = ["+", "-", "*"];
      let a, b, c, op1, op2, expr, structure;
      while(true) {
        a = Math.floor(Math.random()*10)+1;
        b = Math.floor(Math.random()*10)+1;
        c = Math.floor(Math.random()*10)+1;
        op1 = ops[Math.floor(Math.random()*ops.length)];
        op2 = ops[Math.floor(Math.random()*ops.length)];
        structure = Math.random() < 0.5 ? 0 : 1;
        if(structure === 0) {
          if(op1 === "-" && a < b) [a, b] = [b, a];
          let part1 = eval(`${a} ${op1} ${b}`);
          if(op2 === "-" && part1 < c) {
            if(part1 > 0) { c = Math.floor(Math.random()*part1)+1; }
            else continue;
          }
          expr = `(${a} ${op1} ${b}) ${op2} ${c}`;
        } else {
          if(op2 === "-" && b < c) [b, c] = [c, b];
          let part2 = eval(`${b} ${op2} ${c}`);
          if(op1 === "-" && a < part2) { a = Math.floor(Math.random()*10)+part2; }
          expr = `${a} ${op1} (${b} ${op2} ${c})`;
        }
        if(eval(expr) >= 0) break;
      }
      return expr;
    }

    /**************** Ramo AR (Three.js) ****************/
    async function runARVersion() {
      // Importamos módulos AR
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js";
      import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js";

      // Eliminar el overlay (no se usará en AR)
      const overlay = document.getElementById("overlay");
      if(overlay) overlay.remove();

      // Variables AR
      let camera, scene, renderer;
      let correctAnswer;
      let answers = [];
      let questionMesh = null;
      let questionText = "";
      const collisionThreshold = 0.2;
      let correctCount = 0, wrongCount = 0;
      let gameStartTime = 0;
      const gameDuration = 60;
      let gameOver = false;
      let currentQuestionStartTime = 0;
      let correctResponseTimes = [];
      let beepPlayed = false;
      
      // Leaderboard: se usará en AR de forma similar a la función updateLeaderboardPreview2D (puedes adaptarla)
      async function updateLeaderboardAR() {
        const collectionName = `Calcleaderboard_${selectedNumAnswers}`;
        try {
          const q = query(collection(db, collectionName), orderBy("score", "desc"), limit(10));
          let leaderboard = [];
          const querySnapshot = await getDocs(q);
          let pos = 1;
          querySnapshot.forEach(docSnap => {
            const data = docSnap.data();
            leaderboard.push({ pos, name: data.name, score: data.score });
            pos++;
          });
          // Aquí se podría mostrar el leaderboard en AR (por ejemplo, en una malla)
          console.log("Leaderboard AR:", leaderboard);
        } catch(e) {
          console.error("Error en leaderboard AR:", e);
        }
      }

      // Funciones AR (similar a la versión original)
      function updateQuestionPanelAR() {
        const canvas = document.createElement("canvas");
        canvas.width = 512 * 4;
        canvas.height = 128 * 4;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * 4);
        let fontSize = 48 * 4;
        ctx.font = "Bold " + fontSize + "px Arial";
        const maxWidth = canvas.width * 0.9;
        while (ctx.measureText(questionText).width > maxWidth && fontSize > 12 * 4) {
          fontSize -= 2 * 4;
          ctx.font = "Bold " + fontSize + "px Arial";
        }
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        if (questionMesh) {
          questionMesh.material.map = texture;
          questionMesh.material.needsUpdate = true;
        } else {
          const geometry = new THREE.PlaneGeometry(0.6, 0.15);
          const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
          questionMesh = new THREE.Mesh(geometry, material);
          questionMesh.position.set(0, 0.3, -0.8);
          scene.add(questionMesh);
        }
      }

      function createAnswerObjectsAR(numAnswers, initialCreation) {
        const baseRadius = 0.8;
        const minHalfArc = 0.698132;
        const maxHalfArc = Math.PI / 2;
        let halfArc = (numAnswers <= 4) ? minHalfArc :
                      (numAnswers >= 10) ? maxHalfArc :
                      minHalfArc + ((numAnswers - 4) / (10 - 4)) * (maxHalfArc - minHalfArc);
        const angleStart = -halfArc, angleEnd = halfArc;
        if (initialCreation) {
          for (let i = 0; i < numAnswers; i++) {
            const canvas = document.createElement("canvas");
            canvas.width = 256 * 4;
            canvas.height = 256 * 4;
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#007BFF";
            drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * 4);
            ctx.font = "Bold " + (75 * 4) + "px Arial";
            ctx.fillStyle = "#FFFFFF";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const wrongAnswers = new Set();
            while(wrongAnswers.size < (numAnswers-1)) {
              let wrong = Math.floor(Math.random()*100)+1;
              if(wrong !== correctAnswer) wrongAnswers.add(wrong);
            }
            const answersArray = [correctAnswer, ...wrongAnswers];
            answersArray.sort(() => Math.random()-0.5);
            ctx.fillText(answersArray[i], canvas.width/2, canvas.height/2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const geometry = new THREE.PlaneGeometry(0.15, 0.15);
            const mesh = new THREE.Mesh(geometry, material);
            const angle = angleStart + (angleEnd - angleStart) * (i/(numAnswers-1));
            const xOffset = baseRadius * Math.sin(angle);
            const zOffset = -baseRadius * Math.cos(angle);
            mesh.position.set(xOffset, 0, zOffset);
            mesh.userData.answer = answersArray[i];
            answers.push(mesh);
            scene.add(mesh);
          }
        } else {
          // Actualización de texturas en respuestas ya creadas
          // (Se puede implementar de forma similar)
        }
      }

      function generateQuestionAR() {
        const expr = generateQuestionExpr();
        questionText = "¿Cuánto es " + expr + "?";
        correctAnswer = eval(expr);
        updateQuestionPanelAR();
        answers = [];
        createAnswerObjectsAR(selectedNumAnswers, true);
        beepPlayed = false;
        currentQuestionStartTime = performance.now();
      }

      // Configuración básica AR
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5,1,0.25);
      scene.add(light);
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      // Agregar ARButton
      const arButton = ARButton.createButton(renderer, { requiredFeatures: ["hit-test"] });
      arButton.style.position = "absolute";
      arButton.style.top = "450px";
      arButton.style.left = "calc(50% - 75px)";
      document.body.appendChild(arButton);
      // Capturar configuración desde overlay
      selectedNumAnswers = parseInt(document.getElementById("numAnswers").value) || 4;
      const inputName = document.getElementById("playerName").value;
      playerName = inputName !== "" ? inputName : "Jugador";
      // Cuando inicia la sesión AR, removemos el overlay y arrancamos
      renderer.xr.addEventListener("sessionstart", () => {
        generateQuestionAR();
        gameStartTime = performance.now();
        // Actualizar leaderboard AR (puedes crear una malla para mostrarlo en AR; aquí solo se loggea)
        updateLeaderboardAR();
      });
      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
        // Aquí se incluirían actualizaciones de colisiones y efectos, similar al código original
      });
    }

    /**************** Rama 2D (HTML/CSS) ****************/
    function run2DVersion() {
      // La interfaz 2D se basa en contenedores HTML (ya definidos en el body)
      const overlay = document.getElementById("overlay");
      const gameContainer = document.getElementById("gameContainer");
      const questionContainer = document.getElementById("questionContainer");
      const answersContainer = document.getElementById("answersContainer");
      const countdownTimer = document.getElementById("countdownTimer");
      const scoreDisplay = document.getElementById("scoreDisplay");
      const leaderboardPreview = document.getElementById("leaderboardPreview");

      let playerName = "Jugador";
      let selectedNumAnswers = 4;
      let correctAnswer;
      let correctCount = 0, wrongCount = 0;
      let gameStartTime = 0;
      const gameDuration = 60;
      let currentQuestionStartTime = 0;
      let correctResponseTimes = [];

      function generateQuestion2D() {
        const ops = ["+", "-", "*"];
        let a, b, c, op1, op2, expr, structure;
        while(true) {
          a = Math.floor(Math.random()*10)+1;
          b = Math.floor(Math.random()*10)+1;
          c = Math.floor(Math.random()*10)+1;
          op1 = ops[Math.floor(Math.random()*ops.length)];
          op2 = ops[Math.floor(Math.random()*ops.length)];
          structure = Math.random() < 0.5 ? 0 : 1;
          if(structure === 0) {
            if(op1 === "-" && a < b) [a,b] = [b,a];
            let part1 = eval(`${a} ${op1} ${b}`);
            if(op2 === "-" && part1 < c) {
              if(part1 > 0) { c = Math.floor(Math.random()*part1)+1; }
              else continue;
            }
            expr = `(${a} ${op1} ${b}) ${op2} ${c}`;
          } else {
            if(op2 === "-" && b < c) [b,c] = [c,b];
            let part2 = eval(`${b} ${op2} ${c}`);
            if(op1 === "-" && a < part2) { a = Math.floor(Math.random()*10)+part2; }
            expr = `${a} ${op1} (${b} ${op2} ${c})`;
          }
          if(eval(expr) >= 0) break;
        }
        correctAnswer = eval(expr);
        questionContainer.textContent = "¿Cuánto es " + expr + "?";
        currentQuestionStartTime = performance.now();
        const options = generateOptions2D();
        answersContainer.innerHTML = "";
        options.forEach(option => {
          const btn = document.createElement("button");
          btn.textContent = option;
          btn.addEventListener("click", () => answerClicked2D(option));
          answersContainer.appendChild(btn);
        });
      }
      function generateOptions2D() {
        let options = [correctAnswer];
        while(options.length < selectedNumAnswers) {
          let wrong = Math.floor(Math.random()*100)+1;
          if(wrong !== correctAnswer && !options.includes(wrong)) {
            options.push(wrong);
          }
        }
        options.sort(() => Math.random()-0.5);
        return options;
      }
      function answerClicked2D(selected) {
        if(selected === correctAnswer) {
          correctCount++;
          let responseTime = performance.now() - currentQuestionStartTime;
          correctResponseTimes.push(responseTime);
        } else { wrongCount++; }
        updateScore2D();
        setTimeout(generateQuestion2D, 1000);
      }
      function updateScore2D() {
        scoreDisplay.textContent = "Aciertos: " + correctCount + " | Fallos: " + wrongCount;
      }
      let countdownInterval;
      function startCountdown2D() {
        gameStartTime = performance.now();
        countdownInterval = setInterval(() => {
          let elapsed = (performance.now() - gameStartTime)/1000;
          let remaining = Math.max(0, gameDuration - elapsed);
          let seconds = Math.floor(remaining);
          countdownTimer.textContent = "00:" + (seconds < 10 ? "0"+seconds : seconds);
          if(remaining <= 0) { clearInterval(countdownInterval); endGame2D(); }
        }, 1000);
      }
      async function updateLeaderboard2D() {
        const collectionName = `Calcleaderboard_${selectedNumAnswers}`;
        try {
          const q = query(collection(db, collectionName), orderBy("score", "desc"), limit(10));
          const querySnapshot = await getDocs(q);
          let html = "<table><tr><th>Pos</th><th>Nombre</th><th>Puntos</th></tr>";
          let pos = 1;
          querySnapshot.forEach(docSnap => {
            const data = docSnap.data();
            html += `<tr><td>${pos}</td><td>${data.name}</td><td>${data.score}</td></tr>`;
            pos++;
          });
          html += "</table>";
          leaderboardPreview.innerHTML = html;
        } catch(e) {
          console.error("Error en leaderboard 2D:", e);
          leaderboardPreview.innerHTML = "Error cargando leaderboard.";
        }
      }
      async function endGame2D() {
        clearInterval(countdownInterval);
        answersContainer.innerHTML = "";
        questionContainer.textContent = "Juego Terminado";
        scoreDisplay.textContent = "Puntaje final: " + (correctCount - wrongCount);
        // Subir puntaje a Firestore
        const collectionName = `Calcleaderboard_${selectedNumAnswers}`;
        const finalScore = (correctCount - wrongCount);
        try {
          const q = query(collection(db, collectionName), where("name", "==", playerName), limit(1));
          const docs = await getDocs(q);
          if(!docs.empty) {
            const docToUpdate = docs.docs[0];
            await updateDoc(doc(db, collectionName, docToUpdate.id), {
              score: finalScore,
              timestamp: serverTimestamp()
            });
          } else {
            await addDoc(collection(db, collectionName), {
              name: playerName,
              score: finalScore,
              timestamp: serverTimestamp()
            });
          }
        } catch(e) { console.error("Error subiendo puntaje:", e); }
        updateLeaderboard2D();
      }

      // Configuración del botón "Iniciar Juego" ya se ha definido en el overlay.
      // Cuando se pulse, el overlay se oculta y se muestra el contenedor 2D.
      // (Esta lógica ya está definida en el overlay a continuación)
    }

    /**************** Selección de rama ****************/
    async function isARSupported() {
      if(navigator.xr && navigator.xr.isSessionSupported) {
        try {
          return await navigator.xr.isSessionSupported("immersive-ar");
        } catch(e) { return false; }
      }
      return false;
    }

    (async function() {
      const arOK = await isARSupported();
      if(arOK) {
        runARVersion();
      } else {
        // Muestra el overlay (ya está en HTML) y prepara la versión 2D
        run2DVersion();
      }
    })();
  </script>
</body>
</html>
