<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>AR MULTIMUSIC / HTML Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    /* Estilos generales */
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    
    /* Overlay para modo AR */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #aaf951; /* Verde claro */
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 100px;
      z-index: 10;
      box-sizing: border-box;
      text-align: center;
    }
    #overlay a { font-size: 14px; margin: 10px 0; color: blue; text-decoration: none; }
    
    /* Estilos para el modo HTML (fallback) */
    #gameContainer {
      display: none;
      padding: 20px;
      text-align: center;
    }
    #gameContainer h1 { margin-top: 20px; }
    #answersHTML button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
    }
    #timer, #score { font-size: 20px; margin: 10px; }
    #leaderboardPreview {
      max-width: 80%;
      margin: 20px auto;
      background-color: #fff;
      color: #000;
      font-size: 14px;
      border: 1px solid #000;
      border-radius: 6px;
      padding: 10px;
    }
  </style>
</head>
<body>
  <!-- Audios (usados en ambos modos) -->
  <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARCalculation/main/acierto.wav" preload="auto"></audio>
  <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARCalculation/main/error.wav" preload="auto"></audio>
  <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARCalculation/main/timer7.mp3" preload="auto"></audio>
  <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>
  
  <!-- Contenedor overlay para modo AR -->
  <div id="overlay"></div>
  
  <!-- Contenedor para el juego en modo HTML (fallback) -->
  <div id="gameContainer">
    <h1>Multimusic Game</h1>
    <input type="text" id="playerNameHTML" placeholder="Ingresa tu nombre" maxlength="10" style="padding:10px; font-size:16px; display:block; margin: 10px auto;">
    <div>
      <label for="numAnswersHTML">Respuestas:</label>
      <select id="numAnswersHTML">
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
      </select>
    </div>
    <div id="questionHTML" style="margin-top:20px; font-size:24px;"></div>
    <div id="answersHTML" style="margin-top:20px;"></div>
    <div id="timer"></div>
    <div id="score"></div>
    <div id="leaderboardPreview"></div>
    <button id="startGameHTML" style="display:block; margin:20px auto; padding:10px 20px; font-size:16px;">Iniciar Juego</button>
  </div>
  
  <script type="module">
    /***** Firebase y Firestore *****/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
    import { 
      getFirestore, collection, addDoc, orderBy, getDocs, serverTimestamp,
      query, where, limit, updateDoc, doc
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    
    const firebaseConfig = {
      apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
      authDomain: "arm1-acbba.firebaseapp.com",
      projectId: "arm1-acbba",
      storageBucket: "arm1-acbba.firebasestorage.app",
      messagingSenderId: "408825932019",
      appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
      measurementId: "G-S78TM6PVRL"
    };
    
    const appFirebase = initializeApp(firebaseConfig);
    const analytics = getAnalytics(appFirebase);
    const db = getFirestore(appFirebase);
    
    /***** Variables globales comunes *****/
    let correctAnswer;
    let questionText = "";
    let correctCount = 0;
    let wrongCount = 0;
    let gameStartTime = 0;
    let gameDuration = 60; // segundos
    let currentQuestionStartTime = 0;
    let correctResponseTimes = [];
    let selectedNumAnswers = 4;
    let playerName = "Jugador";
    
    /***** Función para generar la pregunta (compartida) *****/
    function generateQuestion() {
      const ops = ["+", "-", "*"];
      let a, b, c, op1, op2, calcExpression, displayExpression, structure;
      while(true){
        a = Math.floor(Math.random()*10)+1;
        b = Math.floor(Math.random()*10)+1;
        c = Math.floor(Math.random()*10)+1;
        op1 = ops[Math.floor(Math.random()*ops.length)];
        op2 = ops[Math.floor(Math.random()*ops.length)];
        structure = Math.random() < 0.5 ? 0 : 1;
        if(structure === 0){
          if(op1 === '-' && a < b){ [a,b] = [b,a]; }
          let part1 = eval(`${a} ${op1} ${b}`);
          if(op2 === '-' && part1 < c){
            if(part1 > 0){
              c = Math.floor(Math.random()*part1)+1;
            } else { continue; }
          }
          calcExpression = `(${a} ${op1} ${b}) ${op2} ${c}`;
          if(eval(calcExpression) >= 0) break;
        } else {
          if(op2 === '-' && b < c){ [b,c] = [c,b]; }
          let part2 = eval(`${b} ${op2} ${c}`);
          if(op1 === '-' && a < part2){
            a = Math.floor(Math.random()*10)+part2;
          }
          calcExpression = `${a} ${op1} (${b} ${op2} ${c})`;
          if(eval(calcExpression) >= 0) break;
        }
      }
      correctAnswer = eval(calcExpression);
      const displayOp1 = op1 === "*" ? "x" : op1;
      const displayOp2 = op2 === "*" ? "x" : op2;
      if(structure === 0){
        displayExpression = `(${a} ${displayOp1} ${b}) ${displayOp2} ${c}`;
      } else {
        displayExpression = `${a} ${displayOp1} (${b} ${displayOp2} ${c})`;
      }
      questionText = `¿Cuánto es ${displayExpression}?`;
      currentQuestionStartTime = performance.now();
    }
    
    /***** MODO AR: Funciones y lógica con Three.js y WebXR *****/
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';
    
    let scene, camera, renderer;
    let questionMesh = null;
    let answers = [];
    let originalAnswerTransforms = null;
    let gameReady = false;
    let countdownMesh = null, countdownCanvas = null, countdownCtx = null, countdownTexture = null;
    let scoreMesh = null, scoreCanvas = null, scoreCtx = null, scoreTexture = null;
    let countdownStarted = false;
    const resolutionFactor = 4;
    const collisionThreshold = 0.2;
    let hasCollided = false;
    let sparksSystems = [];
    let gameOverAR = false;
    
    // Dibuja un rectángulo redondeado en canvas
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    
    // Actualiza el panel de pregunta en AR
    function updateQuestionPanel() {
      const canvas = document.createElement('canvas');
      canvas.width = 512 * resolutionFactor;
      canvas.height = 128 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      let fontSize = 48 * resolutionFactor;
      ctx.font = 'Bold ' + fontSize + 'px Arial';
      const maxWidth = canvas.width * 0.9;
      while (ctx.measureText(questionText).width > maxWidth && fontSize > 12 * resolutionFactor) {
        fontSize -= 2 * resolutionFactor;
        ctx.font = 'Bold ' + fontSize + 'px Arial';
      }
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      if (questionMesh) {
        questionMesh.material.map = texture;
        questionMesh.material.needsUpdate = true;
      } else {
        const geometry = new THREE.PlaneGeometry(0.6, 0.15);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        questionMesh = new THREE.Mesh(geometry, material);
        questionMesh.position.set(0, 0.3, -0.8);
        scene.add(questionMesh);
      }
    }
    
    // Crea (o actualiza) los paneles de respuestas en AR
    function createAnswerObjects(numAnswers, initialCreation) {
      const minHalfArc = 0.698132;
      const maxHalfArc = Math.PI / 2;
      let halfArc = (numAnswers <= 4) ? minHalfArc :
                    (numAnswers >= 10) ? maxHalfArc :
                    minHalfArc + ((numAnswers - 4) / (10 - 4)) * (maxHalfArc - minHalfArc);
      const angleStart = -halfArc;
      const angleEnd = halfArc;
      const radius = 0.8;
      if (initialCreation) {
        originalAnswerTransforms = [];
        for (let i = 0; i < numAnswers; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = 256 * resolutionFactor;
          canvas.height = 256 * resolutionFactor;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#007BFF";
          drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
          ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
          ctx.fillStyle = "#FFFFFF";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const wrongAnswers = new Set();
          while(wrongAnswers.size < (numAnswers - 1)) {
            let wrong = Math.floor(Math.random()*100)+1;
            if(wrong !== correctAnswer) wrongAnswers.add(wrong);
          }
          const answersArray = [correctAnswer, ...wrongAnswers];
          answersArray.sort(() => Math.random()-0.5);
          ctx.fillText(answersArray[i], canvas.width/2, canvas.height/2);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
          const geometry = new THREE.PlaneGeometry(0.15, 0.15);
          const mesh = new THREE.Mesh(geometry, material);
          const angle = angleStart + (angleEnd - angleStart) * (i/(numAnswers-1));
          const xOffset = radius * Math.sin(angle);
          const zOffset = -radius * Math.cos(angle);
          mesh.position.set(xOffset, 0, zOffset);
          const cameraWorldPos = new THREE.Vector3();
          camera.getWorldPosition(cameraWorldPos);
          const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
          mesh.lookAt(lookAtPos);
          mesh.userData.answer = answersArray[i];
          answers.push(mesh);
          scene.add(mesh);
          originalAnswerTransforms.push({
            position: mesh.position.clone(),
            rotation: mesh.rotation.clone()
          });
        }
      } else {
        const wrongAnswers = new Set();
        while(wrongAnswers.size < (selectedNumAnswers - 1)) {
          let wrong = Math.floor(Math.random()*100)+1;
          if(wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random()-0.5);
        for(let i = 0; i < selectedNumAnswers; i++){
          updateAnswerPanel(answers[i], answersArray[i]);
        }
      }
    }
    
    // Actualiza un panel de respuesta (helper)
    function updateAnswerPanel(mesh, value) {
      const canvas = document.createElement('canvas');
      canvas.width = 256 * resolutionFactor;
      canvas.height = 256 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(value, canvas.width/2, canvas.height/2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      mesh.material.map = texture;
      mesh.material.needsUpdate = true;
      mesh.userData.answer = value;
    }
    
    // Crea efecto de chispas en AR
    function createCircleTexture() {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,size,size);
      const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0,0,size,size);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      return texture;
    }
    
    const sparkTexture = createCircleTexture();
    
    function createSparksEffect(position) {
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      for(let i = 0; i < count; i++){
        positions[i*3] = position.x;
        positions[i*3+1] = position.y;
        positions[i*3+2] = position.z;
        velocities.push(new THREE.Vector3(
          (Math.random()-0.5)*0.5,
          (Math.random()-0.5)*0.5,
          (Math.random()-0.5)*0.5
        ));
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.02,
        map: sparkTexture,
        transparent: true,
        opacity: 1.0,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        alphaTest: 0.5,
        sizeAttenuation: true
      });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      sparksSystems.push({
        points,
        velocities,
        startTime: performance.now(),
        lastUpdate: performance.now()
      });
    }
    
    // Displays para countdown y score en AR
    function startCountdown() {
      gameStartTime = performance.now();
      countdownCanvas = document.createElement('canvas');
      countdownCanvas.width = 256 * resolutionFactor;
      countdownCanvas.height = 128 * resolutionFactor;
      countdownCtx = countdownCanvas.getContext('2d');
      countdownTexture = new THREE.CanvasTexture(countdownCanvas);
      countdownTexture.minFilter = THREE.LinearFilter;
      countdownTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.6, 0.3);
      const material = new THREE.MeshBasicMaterial({ map: countdownTexture, transparent: true });
      countdownMesh = new THREE.Mesh(geometry, material);
      countdownMesh.position.set(0, 0.50, -0.82);
      scene.add(countdownMesh);
    }
    
    function createScoreDisplay() {
      scoreCanvas = document.createElement('canvas');
      scoreCanvas.width = 256 * resolutionFactor;
      scoreCanvas.height = 128 * resolutionFactor;
      scoreCtx = scoreCanvas.getContext('2d');
      scoreTexture = new THREE.CanvasTexture(scoreCanvas);
      scoreTexture.minFilter = THREE.LinearFilter;
      scoreTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.6, 0.3);
      const material = new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true });
      scoreMesh = new THREE.Mesh(geometry, material);
      scoreMesh.position.set(0, -0.2, -0.82);
      scene.add(scoreMesh);
    }
    
    function updateCountdown() {
      const elapsed = (performance.now() - gameStartTime) / 1000;
      const remaining = Math.max(0, gameDuration - elapsed);
      const seconds = Math.floor(remaining);
      countdownCtx.clearRect(0, 0, countdownCanvas.width, countdownCanvas.height);
      countdownCtx.fillStyle = (remaining <= 10) ? "red" : "#FFFFFF";
      countdownCtx.font = 'Bold ' + (64 * resolutionFactor) + 'px Arial';
      countdownCtx.textAlign = "center";
      countdownCtx.textBaseline = "middle";
      countdownCtx.fillText(seconds < 10 ? "00:0"+seconds : "00:"+seconds, countdownCanvas.width/2, countdownCanvas.height/2);
      countdownTexture.needsUpdate = true;
      if(remaining <= 10) {
        if(!document.getElementById('beepSound')._played) {
          const beepSound = document.getElementById('beepSound');
          beepSound.currentTime = 0;
          beepSound.play().catch(e=>console.error(e));
          document.getElementById('beepSound')._played = true;
        }
      }
      return remaining;
    }
    
    function updateScoreDisplay() {
      scoreCtx.clearRect(0, 0, scoreCanvas.width, scoreCanvas.height);
      scoreCtx.fillStyle = "#FFFFFF";
      scoreCtx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
      scoreCtx.textAlign = "center";
      scoreCtx.textBaseline = "middle";
      scoreCtx.fillText(`Aciertos: ${correctCount} | Fallos: ${wrongCount}`, scoreCanvas.width/2, scoreCanvas.height/2);
      scoreTexture.needsUpdate = true;
    }
    
    // Render loop en AR, detección de colisiones y efectos
    function animateAR() {
      renderer.setAnimationLoop(renderAR);
    }
    
    function renderAR(timestamp, xrFrame) {
      renderer.render(scene, camera);
      answers.forEach((mesh, index) => {
        if(originalAnswerTransforms && originalAnswerTransforms[index]){
          const baseY = originalAnswerTransforms[index].position.y;
          mesh.position.y = baseY + 0.02 * Math.sin(timestamp * 0.005 + index);
        }
      });
      
      if(gameReady && !countdownStarted) {
        startCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e=>console.error(e));
        countdownStarted = true;
      }
      
      const now = performance.now();
      for(let i = sparksSystems.length - 1; i >= 0; i--){
        const sys = sparksSystems[i];
        const dt = (now - sys.lastUpdate) / 1000;
        sys.lastUpdate = now;
        const pos = sys.points.geometry.attributes.position.array;
        for(let j=0; j<sys.velocities.length; j++){
          pos[j*3+0] += sys.velocities[j].x * dt;
          pos[j*3+1] += sys.velocities[j].y * dt;
          pos[j*3+2] += sys.velocities[j].z * dt;
        }
        sys.points.geometry.attributes.position.needsUpdate = true;
        let life = now - sys.startTime;
        if(life > 1700){
          let fadeTime = life - 1700;
          let fadeFactor = Math.max(0, 1 - (fadeTime/300));
          sys.points.material.opacity = fadeFactor;
        }
        if(life > 2000){
          scene.remove(sys.points);
          sparksSystems.splice(i,1);
        }
      }
      
      if(!gameOverAR){
        const remaining = updateCountdown();
        updateScoreDisplay();
        if(remaining <= 0){
          endGameAR();
        }
      }
      
      // Detección de colisiones: se usa XR o la posición de la cámara
      const session = renderer.xr.getSession();
      let interactionPoints = [];
      if(session && xrFrame){
        for(const inputSource of session.inputSources){
          if(inputSource.hand){
            const indexTip = inputSource.hand.get('index-finger-tip');
            if(indexTip){
              const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
              if(jointPose){
                interactionPoints.push(new THREE.Vector3(
                  jointPose.transform.position.x,
                  jointPose.transform.position.y,
                  jointPose.transform.position.z
                ));
              }
            }
          }
        }
      }
      if(interactionPoints.length === 0){
        let cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        interactionPoints.push(cameraPos);
      }
      
      if(!gameOverAR){
        for(let panel of answers){
          const panelPos = new THREE.Vector3();
          panel.getWorldPosition(panelPos);
          for(const pt of interactionPoints){
            const dist = pt.distanceTo(panelPos);
            if(dist < collisionThreshold && !hasCollided){
              hasCollided = true;
              if(panel.userData.answer === correctAnswer){
                const responseTime = performance.now() - currentQuestionStartTime;
                correctResponseTimes.push(responseTime);
                correctCount++;
                const successSound = document.getElementById('successSound');
                const clone = successSound.cloneNode();
                clone.play().catch(e=>{});
                createSparksEffect(panel.position);
                if(questionMesh) questionMesh.visible = false;
                answers.forEach(a => a.visible = false);
                setTimeout(()=>{
                  if(!gameOverAR){
                    generateQuestion();
                    updateQuestionPanel();
                    answers.forEach(a => a.visible = true);
                  }
                  hasCollided = false;
                },1000);
              } else {
                wrongCount++;
                const errorSound = document.getElementById('errorSound');
                const errClone = errorSound.cloneNode();
                errClone.play().catch(e=>{});
                answers.forEach(a=>a.material.color.set(0xff0000));
                setTimeout(()=>{
                  answers.forEach(a=>a.material.color.set(0xffffff));
                  hasCollided = false;
                },500);
              }
              return;
            }
          }
        }
      }
    }
    
    async function endGameAR() {
      gameOverAR = true;
      if(questionMesh) scene.remove(questionMesh);
      if(countdownMesh) scene.remove(countdownMesh);
      if(scoreMesh) scene.remove(scoreMesh);
      answers.forEach(panel => scene.remove(panel));
      
      let avgTime = 0;
      if(correctResponseTimes.length > 0){
        let sum = correctResponseTimes.reduce((a,b)=>a+b,0);
        avgTime = sum / correctResponseTimes.length / 1000;
      }
      const rawScore = (correctCount - wrongCount) - avgTime;
      const finalScore = parseFloat(rawScore.toFixed(3));
      const collectionName = `Calcleaderboard_${selectedNumAnswers}`;
      
      let docsFound = await getDocs(
        query(
          collection(db, collectionName),
          where("name", "==", playerName),
          limit(1)
        )
      );
      if(!docsFound.empty){
        const docToUpdate = docsFound.docs[0];
        await updateDoc(doc(db, collectionName, docToUpdate.id), {
          score: finalScore,
          timestamp: serverTimestamp()
        });
      } else {
        await addDoc(collection(db, collectionName), {
          name: playerName,
          score: finalScore,
          timestamp: serverTimestamp()
        });
      }
      // Aquí podrías mostrar la tabla final en AR si lo deseas
    }
    
    // Inicializa el modo AR
    function initARGame() {
      const overlay = document.getElementById('overlay');
      overlay.innerHTML =
        '<img src="ARCalc.jpeg" alt="ARCalculation" style="margin-bottom:30px; margin-top:50px; max-width:70%;">' +
        '<a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>' +
        '<div>' +
          '<label for="numAnswers">Respuestas:</label>' +
          '<select id="numAnswers">' +
            '<option value="4">4</option>' +
            '<option value="5">5</option>' +
            '<option value="6">6</option>' +
            '<option value="7">7</option>' +
            '<option value="8">8</option>' +
            '<option value="9">9</option>' +
            '<option value="10">10</option>' +
          '</select>' +
        '</div>' +
        '<div id="leaderboardPreview"></div>' +
        '<input type="text" id="playerName" placeholder="Ingresa tu nombre" style="padding:10px; font-size:16px; margin-bottom:20px;" maxlength="10">';
      
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setReferenceSpaceType('local');
      document.body.appendChild(renderer.domElement);
      
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5,1,0.25);
      scene.add(light);
      
      window.addEventListener('resize', onWindowResize, false);
      
      const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
      arButton.style.position = 'absolute';
      arButton.style.top = '600px';
      arButton.style.left = 'calc(50% - 75px)';
      arButton.style.width = '150px';
      arButton.style.height = '50px';
      arButton.style.fontSize = '16px';
      arButton.style.backgroundColor = 'green';
      arButton.style.color = 'white';
      overlay.appendChild(arButton);
      document.body.appendChild(overlay);
      
      document.getElementById('numAnswers').addEventListener('change', () => {
        const num = parseInt(document.getElementById('numAnswers').value) || 4;
        selectedNumAnswers = num;
      });
      selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
      
      updateLeaderboardPreviewHTML(selectedNumAnswers);
      
      renderer.xr.addEventListener('sessionstart', () => {
        selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
        const inputName = document.getElementById('playerName').value;
        playerName = (inputName !== "") ? inputName : "Jugador";
        correctCount = 0;
        wrongCount = 0;
        correctResponseTimes = [];
        gameStartTime = performance.now();
        generateQuestion();
        updateQuestionPanel();
        createAnswerObjects(selectedNumAnswers, true);
        gameReady = true;
      });
      
      animateAR();
    }
    
    /***** MODO HTML (Fallback) *****/
    let countdownInterval;
    function startHTMLGame() {
      correctCount = 0;
      wrongCount = 0;
      correctResponseTimes = [];
      gameStartTime = performance.now();
      selectedNumAnswers = parseInt(document.getElementById('numAnswersHTML').value) || 4;
      updateLeaderboardPreviewHTML(selectedNumAnswers);
      document.getElementById('startGameHTML').style.display = "none";
      nextHTMLQuestion();
      countdownInterval = setInterval(updateHTMLTimer, 1000);
    }
    
    function nextHTMLQuestion() {
      generateQuestion();
      document.getElementById('questionHTML').textContent = questionText;
      let wrongSet = new Set();
      while(wrongSet.size < (selectedNumAnswers - 1)) {
        let wrong = Math.floor(Math.random()*100)+1;
        if(wrong !== correctAnswer) wrongSet.add(wrong);
      }
      let answersArray = [correctAnswer, ...wrongSet];
      answersArray.sort(() => Math.random()-0.5);
      const answersHTML = document.getElementById('answersHTML');
      answersHTML.innerHTML = "";
      answersArray.forEach(ans => {
        const btn = document.createElement('button');
        btn.textContent = ans;
        btn.onclick = () => checkHTMLAnswer(ans);
        answersHTML.appendChild(btn);
      });
    }
    
    function checkHTMLAnswer(selected) {
      if(selected === correctAnswer) {
        let responseTime = performance.now() - currentQuestionStartTime;
        correctResponseTimes.push(responseTime);
        correctCount++;
        document.getElementById('successSound').currentTime = 0;
        document.getElementById('successSound').play().catch(e=>console.error(e));
      } else {
        wrongCount++;
        document.getElementById('errorSound').currentTime = 0;
        document.getElementById('errorSound').play().catch(e=>console.error(e));
      }
      updateHTMLScore();
      nextHTMLQuestion();
    }
    
    function updateHTMLTimer() {
      let elapsed = (performance.now() - gameStartTime) / 1000;
      let remaining = Math.max(0, gameDuration - elapsed);
      document.getElementById('timer').textContent = remaining <= 10 ?
        "Tiempo: 00:0" + Math.floor(remaining) : "Tiempo: 00:" + Math.floor(remaining);
      if(remaining <= 10) {
        document.getElementById('beepSound').currentTime = 0;
        document.getElementById('beepSound').play().catch(e=>console.error(e));
      }
      if(remaining <= 0) {
        endHTMLGame();
      }
    }
    
    function updateHTMLScore() {
      document.getElementById('score').textContent = `Aciertos: ${correctCount} | Fallos: ${wrongCount}`;
    }
    
    async function endHTMLGame() {
      clearInterval(countdownInterval);
      let avgTime = 0;
      if(correctResponseTimes.length > 0) {
        let sum = correctResponseTimes.reduce((a,b)=>a+b,0);
        avgTime = sum / correctResponseTimes.length / 1000;
      }
      const rawScore = (correctCount - wrongCount) - avgTime;
      const finalScore = parseFloat(rawScore.toFixed(3));
      const collectionName = `Calcleaderboard_${selectedNumAnswers}`;
      let docsFound = await getDocs(
        query(
          collection(db, collectionName),
          where("name", "==", playerName),
          limit(1)
        )
      );
      if(!docsFound.empty){
        const docToUpdate = docsFound.docs[0];
        await updateDoc(doc(db, collectionName, docToUpdate.id), {
          score: finalScore,
          timestamp: serverTimestamp()
        });
      } else {
        await addDoc(collection(db, collectionName), {
          name: playerName,
          score: finalScore,
          timestamp: serverTimestamp()
        });
      }
      updateLeaderboardPreviewHTML(selectedNumAnswers);
      document.getElementById('startGameHTML').textContent = "Reiniciar Juego";
      document.getElementById('startGameHTML').style.display = "block";
    }
    
    // Función para actualizar la mini tabla (leaderboard) (usada en ambos modos)
    async function updateLeaderboardPreviewHTML(numAnswers) {
      const collectionName = `Calcleaderboard_${numAnswers}`;
      try {
        let top3Query = query(
          collection(db, collectionName),
          orderBy("score", "desc"),
          limit(3)
        );
        const querySnapshot = await getDocs(top3Query);
        const results = [];
        querySnapshot.forEach(docSnap => results.push(docSnap.data()));
        const container = document.getElementById('leaderboardPreview');
        container.innerHTML = "";
        if (results.length > 0) {
          let html = "<table style='width:100%; border-collapse: collapse;'>";
          html += "<tr><th style='border: 1px solid #666; padding: 4px;'>Pos</th><th style='border: 1px solid #666; padding: 4px;'>Nombre</th><th style='border: 1px solid #666; padding: 4px;'>Puntos</th></tr>";
          for (let i = 0; i < results.length; i++) {
            html += `<tr>
              <td style='border: 1px solid #666; padding: 4px;'>${i+1}</td>
              <td style='border: 1px solid #666; padding: 4px;'>${results[i].name}</td>
              <td style='border: 1px solid #666; padding: 4px;'>${results[i].score}</td>
            </tr>`;
          }
          html += "</table>";
          container.innerHTML = html;
        } else {
          container.innerHTML = "<p>No hay puntuaciones aún.</p>";
        }
      } catch(err) {
        console.error("Error cargando top 3:", err);
        document.getElementById('leaderboardPreview').innerHTML = "<p>Error cargando clasificación.</p>";
      }
    }
    
    // Ajusta tamaño en cambio de ventana
    function onWindowResize() {
      if(camera && renderer){
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }
    
    // Función para comprobar soporte AR
    async function checkARSupport() {
      if(navigator.xr && navigator.xr.isSessionSupported){
        try {
          return await navigator.xr.isSessionSupported('immersive-ar');
        } catch(e) {
          return false;
        }
      }
      return false;
    }
    
    // Inicialización principal: se elige el modo según la compatibilidad del dispositivo
    (async function(){
      const arSupported = await checkARSupport();
      if(arSupported) {
        initARGame();
      } else {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('gameContainer').style.display = 'block';
        document.getElementById('startGameHTML').addEventListener('click', () => {
          playerName = document.getElementById('playerNameHTML').value || "Jugador";
          startHTMLGame();
        });
      }
    })();
    
    // Desbloquea audio en el primer toque
    window.addEventListener('touchstart', function unlockAudio() {
      [document.getElementById('successSound'), document.getElementById('errorSound')].forEach(audioEl => {
        audioEl.play().then(()=>{
          audioEl.pause();
          audioEl.currentTime = 0;
        }).catch(e=>console.error(e));
      });
    }, { once: true });
    
  </script>
</body>
</html>
